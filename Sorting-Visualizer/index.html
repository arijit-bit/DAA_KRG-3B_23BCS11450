<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Visualizer</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Make body full screen and use a darker background */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Darker background */
            color: #ffffff; /* White text */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Full viewport height */
            width: 100vw; /* Full viewport width */
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
            padding: 0; /* Remove default body padding */
        }
        #app-container {
            display: flex; /* Changed to flex for horizontal layout */
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            background-color: #1f2937; /* Slightly lighter dark background for the container */
            border-radius: 0; /* No border-radius for full screen */
            box-shadow: none; /* No shadow for full screen */
            overflow: hidden;
            border: none; /* No border for full screen */
        }
        #left-sidebar {
            width: 250px; /* Fixed width for the sidebar */
            flex-shrink: 0; /* Prevent shrinking */
            background-color: #1f2937; /* Match app container background */
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-right: 1px solid #374151; /* Subtle separator */
            box-shadow: 5px 0 15px rgba(0, 0, 0, 0.3); /* Shadow for sidebar */
            overflow-y: auto; /* Allow scrolling if many algorithms */
        }
        #main-content-wrapper {
            flex-grow: 1; /* Allows main content to take remaining space */
            display: flex;
            flex-direction: column;
            background-color: #1f2937; /* Match app container background */
        }
        #canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem; /* Increased padding */
            background-color: #252f3e; /* Darker background for canvas area */
            border-radius: 8px; /* Rounded corners for the canvas itself */
            margin: 1rem; /* Add margin to canvas container to separate from panels */
        }
        canvas {
            background-color: #252f3e; /* Match canvas background to container */
            display: block;
            border-radius: 8px;
            max-width: 100%;
            max-height: 100%;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); /* Inner shadow for canvas */
        }
        .btn-base {
            /* Changed base background to bg-gray-800 for better contrast */
            @apply px-5 py-2.5 rounded-lg font-bold transition-all duration-200 ease-in-out
                   bg-gray-800 text-white border border-gray-700 shadow-lg; /* Stronger shadow */
        }
        .btn-base:hover:not(:disabled) {
            /* Changed hover background to bg-gray-700 for clearer effect */
            @apply bg-gray-700 border-gray-500 shadow-xl scale-105; /* More pronounced hover effect */
        }
        .btn-base:disabled {
            @apply opacity-40 cursor-not-allowed;
        }
        .info-label {
            @apply text-base md:text-lg text-gray-300; /* Slightly larger text */
        }

        /* Specific styling for utility buttons (pause/reset) */
        .utility-btn {
            @apply btn-base px-5 py-2.5 text-xl; /* Adjust padding for icon-only buttons */
        }

        /* New styling for algorithm buttons in sidebar */
        .algo-sidebar-btn {
            @apply w-full btn-base px-5 py-2.5 text-base bg-gray-700 border-gray-600 mb-2; /* Darker default */
        }
        .algo-sidebar-btn:hover:not(:disabled) {
            @apply bg-gray-500 border-gray-400 shadow-xl scale-105; /* Specific hover for sidebar buttons */
        }
        .algo-sidebar-btn.active { /* Style for the active/selected algorithm button */
            @apply bg-blue-600 border-blue-500 shadow-xl;
        }
        .algo-sidebar-btn.active:hover {
            @apply bg-blue-700 border-blue-600;
        }

        /* Specific styling for LLM button */
        .llm-btn {
            @apply btn-base px-6 py-2.5 text-base bg-purple-600 border-purple-500;
        }
        .llm-btn:hover:not(:disabled) {
            @apply bg-purple-700 border-purple-600;
        }
        
        /* New style for the "Graph" button */
        .nav-btn {
            @apply btn-base px-5 py-2.5 text-xl bg-green-600 border-green-500; /* Distinct color for graph */
        }
        .nav-btn:hover:not(:disabled) {
            @apply bg-green-700 border-green-600;
        }


        /* Custom scrollbar for better aesthetics if needed */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Left Sidebar -->
        <div id="left-sidebar">
            <h2 class="text-xl font-bold text-white mb-6">Sort Algorithms</h2>
            <div id="sortAlgorithmButtons" class="flex flex-col items-center gap-2 w-full flex-grow">
                <!-- Algorithm buttons will be dynamically added here by JavaScript -->
            </div>
            <!-- Move LLM button to sidebar -->
            <div class="mt-auto pt-6 w-full"> <!-- margin-top: auto to push it to the bottom -->
                <button id="explainAlgoButton" class="llm-btn w-full">✨ Explain Algorithm</button>
            </div>
        </div>

        <!-- Main Content Wrapper -->
        <div id="main-content-wrapper">
            <!-- Top Info Panel -->
            <div class="flex justify-between items-center p-4 bg-gray-900 rounded-tr-xl border-b border-gray-700 flex-wrap gap-y-3">
                <!-- Left aligned info -->
                <div class="flex flex-col md:flex-row md:space-x-6">
                    <div id="statusLabel" class="info-label">Status: Idle</div>
                    <div id="timeComplexityLabel" class="info-label">Time Complexity: N/A</div>
                </div>

                <!-- Right aligned controls and info -->
                <div class="flex flex-col md:flex-row md:space-x-6 items-end md:items-center">
                    <button id="speedButton" class="btn-base mb-2 md:mb-0">Fast</button>
                    <div id="comparisonLabel" class="info-label">Comparisons: 0</div>
                </div>
            </div>

            <!-- Canvas Container -->
            <div id="canvas-container">
                <canvas id="visualizerCanvas" class="rounded-lg"></canvas>
            </div>

            <!-- Bottom Utility Controls Panel -->
            <div class="flex flex-col p-4 bg-gray-900 rounded-br-xl border-t border-gray-700">
                <!-- Utility Buttons (Pause/Reset) -->
                <div class="flex justify-center gap-8">
                    <button id="pauseButton" class="utility-btn flex items-center justify-center" disabled>
                        <span id="pauseIcon">
                            <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                            </svg>
                        </span>
                    </button>
                    <button id="resetButton" class="utility-btn flex items-center justify-center">
                        <span class="text-3xl">⟳</span>
                    </button>
                    <!-- Changed Block Button to Graph Button -->
                    <button id="graphButton" class="nav-btn flex items-center justify-center">
                        <span class="text-2xl">
                            <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path d="M16 11V5h-2v6h-4V8H8v3H4v6h18v-6h-6zM4 19h18v2H4v-2z"/>
                            </svg>
                        </span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Structure for LLM Explanation -->
    <div id="explanationModal" class="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-50 hidden">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl max-w-xl w-11/12 border border-gray-700 relative">
            <h2 class="text-2xl font-bold mb-4 text-white">Algorithm Explanation</h2>
            <div id="modalContent" class="text-gray-300 text-base leading-relaxed overflow-y-auto max-h-96">
                Loading explanation...
            </div>
            <button id="closeModalButton" class="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl">&times;</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('visualizerCanvas');
        const ctx = canvas.getContext('2d');

        // UI Element References
        const statusLabel = document.getElementById('statusLabel');
        const speedButton = document.getElementById('speedButton');
        const timeComplexityLabel = document.getElementById('timeComplexityLabel');
        const comparisonLabel = document.getElementById('comparisonLabel');
        const pauseButton = document.getElementById('pauseButton');
        const pauseIcon = document.getElementById('pauseIcon'); // Reference to the span holding the SVG
        const resetButton = document.getElementById('resetButton');
        const graphButton = document.getElementById('graphButton'); // Changed from blockButton to graphButton
        const sortAlgorithmButtonsContainer = document.getElementById('sortAlgorithmButtons'); // Container for algorithm buttons
        const explainAlgoButton = document.getElementById('explainAlgoButton'); // New LLM button
        const explanationModal = document.getElementById('explanationModal'); // Modal for explanation
        const modalContent = document.getElementById('modalContent'); // Content area of the modal
        const closeModalButton = document.getElementById('closeModalButton'); // Modal close button


        // Configuration
        const ARRAY_SIZE = 15; // Number of blocks (changed from 100, closer to Python example)
        let barWidth = 0; // No longer used for bars, but keeping for consistency if needed for other calcs
        const PADDING_X = 20; // Padding on sides of canvas (used for calculating canvas width)

        // State Variables
        let array = [];
        let isSorting = false;
        let paused = false;
        let stopRequested = false;
        let fastMode = true; // true for fast, false for slow
        let currentStatus = "Idle";
        let highlightA = -1, highlightB = -1;
        let comparisons = 0;
        let currentAlgorithmDisplayName = "N/A"; // To track the currently selected/run algorithm for LLM

        // SVG icons for play/pause
        const playIconSVG = `<svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7z"/></svg>`;
        const pauseIconSVG = `<svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;


        // --- Core Visualization Functions ---

        /**
         * Sets the canvas dimensions based on its parent container.
         * Ensures responsiveness and proper drawing area.
         */
        function setCanvasDimensions() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth - PADDING_X * 2;
            canvas.height = container.clientHeight - PADDING_X * 2; // Use available height
        }

        /**
         * Draws the current state of the array on the canvas in block style.
         * Highlights specific blocks based on `highlightA` and `highlightB`.
         */
        function drawArray() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas
            ctx.fillStyle = '#252f3e'; // Match canvas background to container
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const BLOCK_SPACING = 5; // Spacing between blocks
            
            // Calculate effective width for blocks considering padding and spacing
            const availableWidth = canvas.width - PADDING_X * 2;
            // Calculate maximum possible block size based on available width and number of blocks
            let boxSize = (availableWidth - (array.length - 1) * BLOCK_SPACING) / array.length;

            // Ensure blocks are not too small or too large, clamp to a reasonable range
            const MIN_BOX_SIZE = 40; // Minimum size for readability
            const MAX_BOX_SIZE = 80;  // Maximum size to avoid overflowing on large screens
            boxSize = Math.max(MIN_BOX_SIZE, Math.min(MAX_BOX_SIZE, boxSize));

            // Recalculate total width with adjusted boxSize
            const actualTotalWidth = array.length * boxSize + (array.length - 1) * BLOCK_SPACING;
            // Recalculate offsetX to perfectly center the blocks horizontally
            const offsetX = (canvas.width - actualTotalWidth) / 2;

            // Position blocks vertically in the middle of the canvas
            const centerY = canvas.height / 2;
            const y0 = centerY - boxSize / 2; // Top-left Y for the blocks

            // Font settings for the numbers inside the blocks
            ctx.font = `${Math.max(12, boxSize * 0.4)}px Inter`; // Dynamic font size based on box size
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < array.length; i++) {
                const x0 = offsetX + i * (boxSize + BLOCK_SPACING);
                
                let color = '#3b82f6'; /* Blue-500 from Tailwind */ // Default block color

                // Highlight the current elements being processed
                if (i === highlightA || i === highlightB) {
                    color = '#ef4444'; /* Red-500 from Tailwind */ // Highlighted color
                } 

                // Draw the rounded rectangle
                const cornerRadius = 8; // Increased corner radius for blocks
                ctx.beginPath();
                ctx.roundRect(x0, y0, boxSize, boxSize, cornerRadius);
                ctx.fillStyle = color;
                ctx.fill();

                // Draw the number inside the block
                ctx.fillStyle = '#ffffff'; // White text for numbers
                ctx.fillText(String(array[i]), x0 + boxSize / 2, y0 + boxSize / 2);
            }
        }

        /**
         * Pauses execution for a short duration to visualize changes.
         * Respects `fastMode` and `paused` state.
         */
        async function delay() {
            return new Promise(resolve => {
                const ms = fastMode ? 50 : 150; // Increased delay for slower animation
                setTimeout(() => {
                    // Keep checking if paused and wait if so
                    function checkPaused() {
                        if (paused) {
                            setTimeout(checkPaused, 100); // Check again after 100ms
                        } else {
                            resolve(); // Resume when not paused
                        }
                    }
                    checkPaused();
                }, ms);
            });
        }

        /**
         * Swaps two elements in the array and visualizes the swap.
         * @param {number} i Index of the first element.
         * @param {number} j Index of the second element.
         */
        async function swap(i, j) {
            [array[i], array[j]] = [array[j], array[i]];
            highlightA = i;
            highlightB = j;
            drawArray();
            await delay();
            updateComparisons(comparisons, false);
        }

        // --- UI Update Functions ---

        /** Updates the status label. */
        function updateStatus(status) {
            currentStatus = status;
            statusLabel.textContent = `Status: ${currentStatus}`;
        }

        /** Updates the time complexity label. */
        function updateTimeComplexity(complexity) {
            timeComplexityLabel.textContent = `Time Complexity: ${complexity}`;
        }

        /**
         * Updates the comparison count label.
         * @param {number} count The current comparison count.
         * @param {boolean} isNonComparative True if the sort is non-comparative (e.g., Radix).
         */
        function updateComparisons(count, isNonComparative) {
            if (isNonComparative) {
                comparisonLabel.textContent = `Comparisons: N/A (Non-comparative)`;
            } else {
                comparisonLabel.textContent = `Comparisons: ${count}`;
            }
        }

        /** Disables all sorting algorithm buttons and enables utility buttons. */
        function disableButtons() {
            sortAlgorithmButtonsContainer.querySelectorAll('button').forEach(btn => btn.disabled = true);
            explainAlgoButton.disabled = true;   // Disable LLM button during sort
            pauseButton.disabled = false;
            resetButton.disabled = false;
            speedButton.disabled = false;
            graphButton.disabled = true; // Disable Graph button during sort
        }

        /** Enables all sorting algorithm buttons and disables pause. */
        function enableButtons() {
            sortAlgorithmButtonsContainer.querySelectorAll('button').forEach(btn => btn.disabled = false);
            explainAlgoButton.disabled = false;  // Enable LLM button
            pauseButton.disabled = true;
            graphButton.disabled = false; // Enable Graph button
        }

        /** Sets the active state for the clicked algorithm button. */
        function setActiveAlgoButton(clickedButton) {
            sortAlgorithmButtonsContainer.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
        }

        // --- Array Generation and Reset ---

        /** Fills the array with random numbers. */
        function generateRandomArray() {
            array = [];
            // Generate numbers between 10 and 99, suitable for display in blocks
            for (let i = 0; i < ARRAY_SIZE; i++) {
                array.push(Math.floor(Math.random() * (99 - 10 + 1)) + 10);
            }
            shuffleArray(array); // Ensure randomness for initial state
        }

        /** Fisher-Yates (Knuth) shuffle algorithm. */
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        /** Resets the visualizer to an initial state. */
        function resetVisualizer() {
            stopRequested = true; // Request to stop any ongoing sort
            paused = false;
            isSorting = false;
            highlightA = -1;
            highlightB = -1;
            comparisons = 0;
            generateRandomArray();
            updateStatus("Idle");
            updateTimeComplexity("N/A");
            updateComparisons(0, false);
            drawArray();
            pauseIcon.innerHTML = pauseIconSVG; // Set to pause icon
            enableButtons(); // Re-enable sorting buttons
            setActiveAlgoButton(null); // Clear active button
            currentAlgorithmDisplayName = "N/A"; // Reset current algorithm display name
        }

        // --- Sorting Algorithm Implementations ---

        /**
         * Generic function to start a sorting algorithm.
         * @param {string} sortName Name of the sorting algorithm.
         * @param {Function} sortMethod The async function implementing the sort.
         */
        async function startSorting(sortName, sortMethod, clickedButton) {
            if (isSorting) {
                // If a sort is already running, request it to stop.
                stopRequested = true;
                // Wait for the current sort to finish its cleanup.
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            stopRequested = false;
            paused = false;
            isSorting = true;
            comparisons = 0; // Reset comparisons for new sort
            updateStatus(`Sorting: ${sortName}`);
            pauseIcon.innerHTML = pauseIconSVG; // Ensure pause button shows 'Pause' icon
            currentAlgorithmDisplayName = sortName; // Update for LLM feature
            setActiveAlgoButton(clickedButton); // Set the clicked button as active

            let isNonComparative = false;
            switch (sortName) {
                case "Bubble Sort": updateTimeComplexity("O(n^2)"); break;
                case "Selection Sort": updateTimeComplexity("O(n^2)"); break; // Added Selection Sort complexity
                case "Insertion Sort": updateTimeComplexity("O(n^2)"); break;
                case "Binary Sort": updateTimeComplexity("O(n^2)"); break; // Updated name
                case "Merge Sort": updateTimeComplexity("O(n log n)"); break;
                case "Quick Sort": updateTimeComplexity("O(n log n) (avg)"); break;
                case "Radix Sort": updateTimeComplexity("O(nk)"); isNonComparative = true; break;
                case "Bucket Sort": updateTimeComplexity("O(n+k) (avg)"); isNonComparative = true; break;
                case "Counting Sort": updateTimeComplexity("O(n+k)"); isNonComparative = true; break;
                default: updateTimeComplexity("N/A"); break;
            }
            updateComparisons(comparisons, isNonComparative);
            disableButtons();

            // Start the sorting process
            try {
                await sortMethod();
            } catch (error) {
                console.error("Sorting error:", error);
            } finally {
                // Ensure state is reset whether sorting completes or is stopped
                highlightA = -1;
                highlightB = -1;
                drawArray(); // Final repaint
                isSorting = false;
                currentStatus = stopRequested ? "Stopped" : "Done";
                updateStatus(currentStatus);
                updateComparisons(comparisons, isNonComparative);
                enableButtons();
                // Keep the last run algorithm button active, or clear if reset.
                if (currentStatus === "Done") {
                    setActiveAlgoButton(clickedButton); // Keep the button active if done
                } else {
                    setActiveAlgoButton(null); // Clear if stopped (e.g. by reset)
                }
            }
        }

        // Bubble Sort
        async function bubbleSort() {
            for (let i = 0; i < array.length - 1 && !stopRequested; i++) {
                for (let j = 0; j < array.length - i - 1 && !stopRequested; j++) {
                    comparisons++;
                    if (array[j] > array[j + 1]) {
                        await swap(j, j + 1);
                    }
                    drawArray(); // Redraw with highlights after comparison, even if no swap
                    highlightA = j;
                    highlightB = j + 1;
                    await delay();
                }
            }
        }

        // Selection Sort (New implementation)
        async function selection_sort() {
            const n = array.length;
            for (let i = 0; i < n - 1 && !stopRequested; i++) {
                let min_idx = i;
                for (let j = i + 1; j < n && !stopRequested; j++) {
                    comparisons++;
                    highlightA = min_idx; // Highlight current minimum candidate
                    highlightB = j;       // Highlight element being compared
                    drawArray();
                    await delay();

                    if (array[j] < array[min_idx]) {
                        min_idx = j;
                    }
                    updateComparisons(comparisons, false);
                }
                if (min_idx !== i) { // Only swap if a new minimum was found
                    await swap(i, min_idx);
                }
                highlightA = i; // Mark 'i' as sorted (conceptually)
                highlightB = -1; // Clear second highlight
                drawArray();
                await delay();
            }
        }

        // Insertion Sort
        async function insertionSort() {
            for (let i = 1; i < array.length && !stopRequested; i++) {
                let key = array[i];
                let j = i - 1;

                highlightB = i; // Highlight the key element
                drawArray();
                await delay();

                while (j >= 0 && !stopRequested) {
                    comparisons++;
                    if (array[j] > key) {
                        array[j + 1] = array[j];
                        highlightA = j;
                        highlightB = j + 1;
                        drawArray();
                        await delay();
                        j--;
                    } else {
                        break;
                    }
                    updateComparisons(comparisons, false);
                }
                array[j + 1] = key;
                highlightA = j + 1;
                highlightB = -1;
                drawArray();
                await delay();
            }
        }

        // Binary Insertion Sort Helper
        async function binarySearchInsertionPoint(arr, low, high, key) {
            while (low <= high) {
                if (stopRequested) return low; // Allow stopping
                let mid = Math.floor(low + (high - low) / 2);

                highlightA = mid; // Highlight the mid element
                highlightB = -1;
                drawArray();
                await delay();

                comparisons++;
                updateComparisons(comparisons, false);

                if (arr[mid] > key) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            return low;
        }

        // Binary Sort (formerly Binary Insertion Sort)
        async function binarySort() { // Renamed function
            for (let i = 1; i < array.length && !stopRequested; i++) {
                let key = array[i];
                highlightB = i; // Highlight key
                drawArray();
                await delay();

                let insertedIndex = await binarySearchInsertionPoint(array, 0, i - 1, key);

                // Shift elements
                for (let j = i - 1; j >= insertedIndex && !stopRequested; j--) {
                    array[j + 1] = array[j];
                    highlightA = j;
                    highlightB = j + 1;
                    drawArray();
                    await delay();
                }
                array[insertedIndex] = key;
                highlightA = insertedIndex;
                highlightB = -1;
                drawArray();
                await delay();
            }
        }

        // Merge Sort
        async function mergeSortRecursive(arr, left, right) {
            if (left >= right || stopRequested) return;
            let mid = Math.floor(left + (right - left) / 2);
            await mergeSortRecursive(arr, left, mid);
            await mergeSortRecursive(arr, mid + 1, right);
            await merge(arr, left, mid, right);
            drawArray();
            await delay();
        }

        async function merge(arr, left, mid, right) {
            let temp = [];
            let i = left, j = mid + 1, k = 0;

            while (i <= mid && j <= right && !stopRequested) {
                highlightA = i;
                highlightB = j;
                drawArray();
                await delay();

                comparisons++;
                updateComparisons(comparisons, false);
                if (arr[i] < arr[j]) {
                    temp.push(arr[i++]);
                } else {
                    temp.push(arr[j++]);
                }
            }
            while (i <= mid && !stopRequested) {
                highlightA = i;
                highlightB = -1;
                drawArray();
                await delay();
                temp.push(arr[i++]);
            }
            while (j <= right && !stopRequested) {
                highlightA = j;
                highlightB = -1;
                drawArray();
                await delay();
                temp.push(arr[j++]);
            }

            for (k = 0; k < temp.length && !stopRequested; k++) {
                arr[left + k] = temp[k];
                highlightA = left + k;
                highlightB = -1;
                drawArray();
                await delay();
            }
        }

        // Quick Sort
        async function quickSortRecursive(arr, low, high) {
            if (low < high && !stopRequested) {
                let pi = await partition(arr, low, high);
                highlightA = pi;
                highlightB = -1;
                drawArray();
                await delay();
                await quickSortRecursive(arr, low, pi - 1);
                await quickSortRecursive(arr, pi + 1, high);
            }
        }

        async function partition(arr, low, high) {
            let pivot = arr[high];
            highlightB = high; // Highlight pivot
            let i = low - 1;

            for (let j = low; j < high && !stopRequested; j++) {
                comparisons++;
                updateComparisons(comparisons, false);
                if (arr[j] < pivot) {
                    i++;
                    await swap(i, j);
                }
                highlightA = j;
                drawArray();
                await delay();
            }
            await swap(i + 1, high);
            return i + 1;
        }

        // Radix Sort
        async function radixSort() {
            let max = 0;
            for (let i = 0; i < array.length; i++) {
                if (array[i] > max) max = array[i];
            }

            for (let exp = 1; Math.floor(max / exp) > 0 && !stopRequested; exp *= 10) {
                await countSortForRadix(exp);
                drawArray();
                await delay();
            }
        }

        async function countSortForRadix(exp) {
            let output = new Array(array.length);
            let count = new Array(10).fill(0);

            for (let i = 0; i < array.length; i++) {
                if (stopRequested) return;
                count[Math.floor((array[i] / exp) % 10)]++;
                highlightA = i; // Show element being processed for digit count
                highlightB = -1;
                drawArray();
                await delay();
            }

            for (let i = 1; i < 10; i++) {
                count[i] += count[i - 1];
            }

            for (let i = array.length - 1; i >= 0; i--) {
                if (stopRequested) return;
                let digit = Math.floor((array[i] / exp) % 10);
                output[count[digit] - 1] = array[i];

                highlightA = i; // Element in original array
                highlightB = count[digit] - 1; // Conceptual target position in output
                drawArray();
                await delay();

                count[digit]--;
            }

            for (let i = 0; i < array.length; i++) {
                if (stopRequested) return;
                array[i] = output[i];
                highlightA = i; // Element being copied back
                highlightB = -1;
                drawArray();
                await delay();
            }
        }

        // Bucket Sort
        async function bucketSort() {
            let maxVal = 0;
            for (let i = 0; i < array.length; i++) {
                if (array[i] > maxVal) maxVal = array[i];
            }

            const bucketCount = 10;
            let buckets = [];
            for (let i = 0; i < bucketCount; i++) {
                buckets.push([]);
            }

            // Distribute elements into buckets
            for (let i = 0; i < array.length && !stopRequested; i++) {
                const num = array[i];
                // Scale value to fit into buckets based on its range (10-99 for now)
                const idx = Math.floor(((num - 10) * bucketCount) / (99 - 10 + 1));
                buckets[idx].push(num);

                // Highlight the element being placed into a bucket (conceptually)
                highlightA = i;
                highlightB = -1;
                drawArray();
                await delay();
            }

            let index = 0;
            // Sort each bucket and concatenate
            for (let i = 0; i < bucketCount && !stopRequested; i++) {
                const bucket = buckets[i];
                bucket.sort((a, b) => a - b); // Sort elements within each bucket

                for (let j = 0; j < bucket.length && !stopRequested; j++) {
                    array[index++] = bucket[j];
                    highlightA = index - 1; // Highlight element being placed back
                    highlightB = -1;
                    drawArray();
                    await delay();
                }
            }
        }

        // Counting Sort
        async function countingSort() {
            // Numbers are generated between 10 and 99
            let min = 10;
            let max = 99;
            const range = max - min + 1;

            let count = new Array(range).fill(0);
            let output = new Array(array.length);

            // Store count of each element
            for (let i = 0; i < array.length && !stopRequested; i++) {
                count[array[i] - min]++;
                highlightA = i; // Highlight element being counted
                highlightB = -1;
                drawArray();
                await delay();
            }

            // Store cumulative count
            for (let i = 1; i < count.length && !stopRequested; i++) {
                count[i] += count[i - 1];
            }

            // Build the output array
            // Iterate from the end to ensure stability
            for (let i = array.length - 1; i >= 0 && !stopRequested; i--) {
                let value = array[i];
                let outputIndex = count[value - min] - 1;
                output[outputIndex] = value;

                highlightA = i; // Element from original array
                highlightB = outputIndex; // Conceptual target position in output array
                drawArray();
                await delay();

                count[value - min]--;
            }

            // Copy the output array to array[]
            for (let i = 0; i < array.length && !stopRequested; i++) {
                array[i] = output[i];
                highlightA = i; // Element being copied back
                highlightB = -1;
                drawArray();
                await delay();
            }
        }


        // --- Event Listeners and Initialization ---

        /** Sets up all event listeners for buttons and the select box. */
        function setupEventListeners() {
            // Speed Button
            speedButton.addEventListener('click', () => {
                fastMode = !fastMode;
                speedButton.textContent = `${fastMode ? 'Fast' : 'Slow'}`;
            });

            // Pause/Resume Button
            pauseButton.addEventListener('click', () => {
                paused = !paused;
                // Toggle between play and pause icons
                pauseIcon.innerHTML = paused ? playIconSVG : pauseIconSVG;
                updateStatus(paused ? 'Paused' : (isSorting ? 'Sorting...' : 'Idle'));
            });

            // Reset Button
            resetButton.addEventListener('click', () => {
                resetVisualizer();
            });

            // Graph Button - navigates to index.html
            graphButton.addEventListener('click', function () {
                window.location.href = 'graph.html'; // Navigate to graph.html
            });

            // Define sorting algorithms and their corresponding methods
            const sortAlgorithms = [
                { name: "Bubble", method: bubbleSort, display: "Bubble Sort" },
                { name: "Selection", method: selection_sort, display: "Selection Sort" }, // Added Selection Sort
                { name: "Insertion", method: insertionSort, display: "Insertion Sort" },
                { name: "BinaryInsertion", method: binarySort, display: "Binary Sort" }, // Updated name and function call
                { name: "Merge", method: () => mergeSortRecursive(array, 0, array.length - 1), display: "Merge Sort" },
                { name: "Quick", method: () => quickSortRecursive(array, 0, array.length - 1), display: "Quick Sort" },
                { name: "Radix", method: radixSort, display: "Radix Sort" },
                { name: "Bucket", method: bucketSort, display: "Bucket Sort" },
                { name: "Counting", method: countingSort, display: "Counting Sort" },
            ];

            // Populate the sidebar with algorithm buttons
            sortAlgorithms.forEach(algo => {
                const btn = document.createElement('button');
                btn.textContent = algo.display;
                btn.classList.add('algo-sidebar-btn');
                btn.addEventListener('click', () => {
                    resetVisualizer(); // Always reset before starting a new sort
                    setTimeout(() => startSorting(algo.display, algo.method, btn), 50); // Pass the button reference
                });
                sortAlgorithmButtonsContainer.appendChild(btn);
            });

            // --- LLM Integration: Explain Algorithm ---
            explainAlgoButton.addEventListener('click', async () => {
                const selectedAlgoName = currentAlgorithmDisplayName; // Use the tracked algorithm name
                if (selectedAlgoName === "N/A") {
                    modalContent.innerHTML = '<p class="text-yellow-400">Please run a sorting algorithm first to get an explanation.</p>';
                    explanationModal.classList.remove('hidden');
                    return;
                }

                modalContent.innerHTML = '<p class="text-center text-xl text-blue-300">Loading explanation... <span class="animate-spin inline-block ml-2 text-2xl">&#9696;</span></p>';
                explanationModal.classList.remove('hidden'); // Show modal

                try {
                    // Update prompt to use "Binary Sort" for clarity if it's the current algo
                    const promptAlgoName = selectedAlgoName === "Binary Sort" ? "Binary Insertion Sort" : selectedAlgoName;
                    const prompt = `Provide a concise explanation of the "${promptAlgoName}" sorting algorithm. Include its working principle, time complexity (best, average, and worst case), and ideal use cases. Format it clearly using paragraphs.`;
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = { contents: chatHistory };
                    const apiKey = ""; // Canvas will provide this.
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} - ${errorData.error.message || 'Unknown error'}`);
                    }

                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        modalContent.innerHTML = text.replace(/\n/g, '<br>'); // Replace newlines with <br> for display
                    } else {
                        modalContent.innerHTML = '<p class="text-red-400">Could not retrieve explanation. Please try again.</p>';
                        console.error("Gemini API response structure unexpected:", result);
                    }
                } catch (error) {
                    modalContent.innerHTML = `<p class="text-red-400">Error: ${error.message}. Failed to fetch explanation.</p>`;
                    console.error("Error fetching explanation from Gemini API:", error);
                }
            });

            closeModalButton.addEventListener('click', () => {
                explanationModal.classList.add('hidden'); // Hide modal
            });

            // Also hide modal if clicked outside (optional but good UX)
            explanationModal.addEventListener('click', (event) => {
                if (event.target === explanationModal) {
                    explanationModal.classList.add('hidden');
                }
            });
            // --- End LLM Integration ---
        }

        // --- Initial Setup ---
        window.addEventListener('load', () => {
            setCanvasDimensions();
            generateRandomArray();
            drawArray();
            setupEventListeners();

            // Handle window resizing for responsive canvas
            window.addEventListener('resize', () => {
                setCanvasDimensions();
                drawArray(); // Redraw array on resize
            });
        });

    </script>
</body>
</html>